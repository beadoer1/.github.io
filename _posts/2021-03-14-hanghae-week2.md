---
title: "항해99 2주차 WIL(알고리즘 풀이법에 대한 고찰)"
date: 2021-03-14 21:31:00 +0900
categories:
  - 항해99 WIL
tags:
  - 항해99
  - WIL
  - Week I Learned
  - week2
---

※ 알고리즘 풀이 코드 구현 [github.com/beadoer1/algorithm](https://github.com/beadoer1/algorithm)  
※ 관련 지식정리 [github.com/beadoer1/TIL](https://github.com/beadoer1/TIL)  
 
## 매일을 하루종일 알고리즘 풀이하기
 이번주는 매일을 하루종일 알고리즘을 풀이하는 시간을 가졌다.  
 하여, 해당 WIL에는 알고리즘을 풀며 적절한 풀이법을 찾는 과정에 대해 고찰 해보려 한다.

## 알고리즘 풀이법에 대한 고찰
### **모르는 이론이 등장했을 때는 무작정 풀어보기보다 이론을 먼저 익힌다.**  
  
이 부분은 항해99라는 프로그램에 참가 중이라 할 수 있는 것인지도 모르겠다. 항해99의 알고리즘 주차에는 풀어야하는 알고리즘 문제를 해당 알고리즘의 개념과 함께 내어준다.(예를 들면, '영화감독 숌:브루트포스'와 같은 식이다.) 이 때, 브루트포스라는 알고리즘 접근방식에 대해 알지 못하고 문제를 맞이하게 되면 앞에서 문제 이전에 풀어온 다른 문제들과 같이 '분명 이 안에도 특정한 수열이나 규칙이 존재할거야.'하는 생각을 가질 것이고, 무작정 손으로 숫자를 하나하나 써보며 처음 발견한 수열로 문제를 풀어볼 것이다. 하지만 이 문제는 중간에 수열의 방식이 여러번 바뀐다. 나도 생각없이 처음 이 문제를 접했을 때는 '아, 16진법이네~' 생각했다가 코딩 직전에 브루트포스를 알아보고 다른 경우도 있음을 뒤늦게 알아챘다. 이전에 보았던 DFS와 BFS 방식도 마찬가지로 SCC 알고리즘 강의를 보고나서 접근이라도 할 수 있었고, 링크드리스트,딕셔너리(Java는 hashMap) 등도 강의를 통해 실제 코드로 해당 class들을 만들고 나니 명확히 이해하고 풀어갈 수 있게 되었다. 물론, 무조건적인 접근이 생각하지 못한 방식의 해답으로 다가올 때도 있기는 하지만, 오히려 많은 이론을 알고 있을 때 더 많은 경우의 수를 시도해 볼 수도 있다고 생각한다. 답을 보고 시작하자는게 아니고 여러 풀이법에 대해 정확히 알고 넘어가자. 
  
### **'앞선  과정의 선택이 이후 과정에 영향을 미치는 경우' 재귀적 관점으로 다가간다.**  
  
먼저, '재귀적 관점'이라고 해서 꼭 재귀함수로 풀자는 것은 아니다. 단지, 문제를 주어진 과정과 반대로 결과값부터 앞으로의 순서로 생각해 볼 필요가 있다고 느꼈다. `'앞선 과정의 선택이 이후 과정에 영향을 미치는 경우'` 매순간 선택에 따라 뒤의 결과는 달라지게 된다. 하여, 지금의 내 선택이 최선인지 알면서 전진하려면 가능한 경우를 다 따져가면서 전진하는 방법을 택해야 한다. 이 때 떠올릴 수 있는 것이 **`'재귀적 관점'`** 이다. 과정의 중간 혹은 끝에 서있다고 가정할 때, `'내 바로 앞까지의 과정은 최선의 과정(원하는 결과값)이다.'` 라는 가정으로 앞의 과정을 바라보는 것이다. 그리고 계속해서 이전의 단계로 돌아가보면 이는 결국 최선을 위한 과정을 역으로 되짚어 본 것이 된다. 이러한 생각을 통해 앞의 과정이 뒤의 결과값에 어떠한 영향을 주는지 보고 이를 함수로 작성하여 문제를 해결할 수 있었다.  
대표적으로, [백준 1932번 '정수 삼각형' 문제](https://www.acmicpc.net/problem/1932)가 그러했다. 이 문제는 아래 그림과 같이 정수로 이루어진 탑을 입력값으로 받고 꼭대기부터 아랫줄 좌우에 있는 값을 더하며 내려가 가장 마지막에 도달했을 때의 결과값 중 최대값을 출력하는 문제이다.  
<p align="center"><img src="/assets/images/정수삼각형.png"></p>  
우선, 주어진대로 위에서부터 생각해본다면,
```
※ in_line은 줄 l개의 줄번호(0~l-1), in_num은 해당 줄의 숫자 n개의 index(0~n-1)이다. 
1. 맨 윗값(인덱스:0)을 아랫줄의 양쪽에 있는 값에 더한다.
2. 두 번째 줄(in_line:1)의 값(in_num:0~1)들을 차례로 아랫줄(in_line:2)의 값(in:0~2)중 본인의 양쪽에 있는 값을 더해 내려가고, 
3. 아랫줄(in_line:2)의 가운데 중복되는 부분(in_num:1)에 대해서는 비교를 통해 더 큰 값을 남긴다.
4. 세 번째 줄의 값들을 2의 과정과 같이 차례로 해당 값의 아랫줄 양쪽에 더하고,
5. in_num:1~n-2 에 해당하는 값들은 이전 줄의 값을 더한 합을 비교해 큰 값을 남긴다.
6. 위 과정을 n-1번 인덱스까지 반복하여 최대값을 출력한다.
```
와 같이 써볼 수 있는데, 이는 실제로 알고리즘을 코딩하는 것 자체도 쉽지 않고 이전의 반복에서 더한 결과 값을 계속 다시 불러와 비교해야 한다는 복잡성을 가지고 있다. 해서 재귀적 관점으로 생각해본다면, 먼저 아래와 같은 생각을 해볼 수 있다.  
```
1. 맨 아랫 줄(in_line:l-1)의 값(in_num:0~n-1)에서 바라보는 윗 줄(in_line:n-2)은 현재 최댓값으로 합쳐져서 내려온 상태이다. 
  하여, 윗 줄을 바라보고 양쪽에 있는 값을 비교하여 더 큰 값을 자신에게 더한다.(이 부분이 재귀의 메인 함수가 된다.)
2. 맨 아래부터 위로 올라며 두 번째 줄까지 위와 같은 과정을 거쳤을 것이다.
3. 위와 같은 관점으로 맨 위까지 올라가 보면...
4. 두 번째 줄에서 첫 번째 줄을 볼 때 숫자가 하나이므로 두 번째 줄의 값들은 그저 자신에게 위의 값을 더하면 된다.
  (재귀를 구현한 함수의 초기값이 된다.(if in_line==0: return value))
5. 세 번째 줄에서 두 번째 줄을 볼 때 본인의 양 옆에 있는 이전의 결과값을 먼저 본 후에 그 중 큰 값을 자신에게 더한다.
6. 맨 끝까지 위 4,5와 같은 과정을 거쳐 다시 돌아오면 맨 아랫 줄에는 각 index 별 최댓값만 남게되고 이를 비교해 출력하면 된다.
```
위 두 방법의 차이는 _'실행을 한 후 결과값을 예측하느냐'_ vs _'결과값을 미리 예측한 후 실행을 하느냐'_ 로 볼 수 있겠다. 실행과 예측을 두 단계(혹은 그 이상)로 나누느냐 아니면 한 단계에서 둘 다 실행할 수 있느냐의 차이인 것이다. 개인적으로는 후자가 훨씬 쉽고 편한 방법이라고 결론지었다.  
  
이야기가 좀 길어졌다. 금주에 가장 깊게 생각해 본 부분이라 자세히 써보았는데 향후에 다시 봤을 때도 내가 무슨 생각으로 이 글을 썼는지 알 수 있었으면 좋겠다..(글을 쉽게 쓰는게 참 쉽지 않다.) 실제 풀이 코드는 이 곳에 남겨 놓았다.['백준 1932번 풀이 link'](https://github.com/beadoer1/algorithm/blob/master/20210313/1932.py)  
  
### **재귀함수는 대부분(반례가 있을지도 몰라 대부분이라고 쓴다.) 반복문으로 변환 가능하다.**  
  
'재귀적 관점'이라고 하여 꼭 재귀함수를 쓸 필요는 없다고 한 이유가 이것이다. 개인적으로는 재귀적 관점으로 문제를 봤을 때 재귀함수를 이용해 문제에 접근하는 것이 더 편해서 이를 이용해 문제를 풀었었다. 그런데 문제를 다 푼 후 항해99 팀원들과 답을 공유할 때, 팀원들은 항상 반복문(for문)으로 된 답안을 가지고 오셨다. 그리고 이런 과정을 통해 재귀함수는 대부분(지금까지는 전부 다) 반복문으로 고칠 수 있음을 알게 되었다.  
  
지난 10일 간 알고리즘을 겪으면 내게 가장 큰 스트레스를 줬던 것이 백준의 '런타임 에러'였는데 이를 알아보다가 [RecursionError](https://www.acmicpc.net/help/rte/RecursionError)에 대해 읽게 되었다. 그리고 BOJ(Baekjoon Online Judge)의 채점 서버에서는 재귀함수 깊이의 한계 값을 1,000으로 지정해놓은 것을 알게 되었다. 물론, 이제껏 이것 때문에 런타임 에러가 나왔던 적은 없었다.(그렇다고 착각했으나 import를 빼먹고 올린 경우(이또한 런타임 에러..)는 있었다.) 무튼, 이것이 시사하는 바는 재귀함수에는 그 한계가 지정되어 있다는 것이고, 이는 재귀함수를 쓰지 못하는 경우도 있다는 것을 의미했다.  
  
해서, 재귀적 관점으로 바라봐야할 문제는 for문으로도 남길 수 있다는 점을 기록해본다. for문의 경우 처음부터 순차적으로 돌리기 때문에 거꾸로 되짚어가는 재귀적으로 생각하는게 처음엔 좀 어색했다. 그래도 계속 보다보니 재귀함수처럼 초기값 지정, 예외 설정, 재귀식 구현 으로 나누어짐을 알 수 있었다. 하나 Tip은 재귀함수는 내가 제일 끝에 서있다고 생각한 반면 for문은 반복의 두 번째 혹은 세 번째쯤 서서 앞을 본다고 생각하니 조금 편했다. 뭔가 길을 뒤로 돌아서 거꾸로 걸어가는 기분으로 관찰한달까..  
   
### **재귀함수 혹은 같은 과정을 여러번 처리해서 출력해야하는 경우에는 '동적계획법'을 사용하자.**  
'어째 죄다 재귀다..' 할 수 있겠지만, 실제로 재귀에 대한 문제를 많이 풀었고 그만큼 기억에 남는 것도 사실이다. 다른 것들은 그저 개념에 대한 것이나, 아직 어떤 상황에 써야할 지 스스로 명확히 이해하지 못한 부분들이라 개념은 [TIL](https://github.com/beadoer1/TIL)에 정리하고 후자는 더 알아볼 예정이다.  
  
일단, 위 이야기는 '동적계획법(Dynamic Programming)'을 알게된 지금은 너무 당연한 이야기일 수 있지만 그 전까지는 몰라서 못써먹던 개념이라 '이론과 실제의 병행'이 느껴진 부분으로 WIL에 남겨본다. 간단하게 **`'동적계획법'`**은 `'문제를 결정하는 과정이 단계 별로 죄다 연결되어있는 경우, 각 단계의 결과가 달성하고자 하는 최종 목표에도 영향을 미치게 된다. 하여, 작은 단계부터 각 단계 별로 최적값을 구하고 다음 단계로 넘기는 기법.'` 정도로 이야기 할 수 있겠다. 뭔가 앞에 이야기했던 것들이 잔상처럼 남는다. 동적계획법을 배웠는데 왜 재귀가 떠오르는지 모르겠다.  
  
재귀 이야기를 꺼낸 김에 재귀를 먼저 예로 들어보자. 재귀의 구현 방식은 실제로 위에 이야기 한 동적계획법 설명과 정확히 일치한다. 이전 단계까지의 답이 있어야만 최종 결과를 도출할 수 있기 때문이다. 만약, 내가 num(n)을 num(n-1)+num(n-2)라는 재귀식을 가지고 num(0)=0, num(1)=1 인 함수를 짰다고 가정해보자. 그럼 아래와 같은 순서를 거치게 된다.
```
1. 먼저 num(n)을 구하려면 num(n-1)을 알아야 하므로 이를 구하기 위해 num(n-1) = num(n-2)+num(n-3)을 실행한다. 
2. 그럼 다시 위 1번의 num(n-2)를 구해야 하므로 num(n-2) = num(n-3)+num(n-4) 를 구한다.
3. 위 과정을 계속 반복(...)해서 마지막에는 num(2) = num(1)+num(0) = 1+0 = 1 이라는 값에 도달한다.
4. 됐다! 이제 num(3) 다시 올라가 num(3) = num(2)+num(1) = 1+1 = 2임을 알게됐다. 
5. 그럼 num(4)로 다시 올라가 num(4) = num(3)+num(2) = 2 + num(2) 가 되고,
6. 이제는 다시 num(2)를 구해야 하니 num(2) = num(1)+num(0) = 1+0 = 1 이라는 값에 도달한다.
7. 좋아! num(4) = 2 + 1 = 3 이 됨을 알 수 있다.
8. 다시 num(5)로 다시 올라가 num(5) = num(4)+num(3) = 3 + num(3) 이되고..
9. 다시 num(3)을 구해야 하니...  
```
위 과정을 보면 너무나 당연하게도 '대체 num(2), num(3)은 구해놓고 왜 또 구하고 앉아 있는거지??'라는 의문을 가지게 된다. 여기서 `**Memoization(메모이제이션)**`이라는 개념이 등장한다. 이는 간단하게 `'메모하여 놓음'` 정도의 의미로 볼 수 있는데, 위 의문은 우리가 자연스레 3~5번 과정을 거치며 num(2)=1,num(3)=2 라는 것을 머릿속에 '메모이제이션'했기 때문에 발생하는 것이다.  
  
위 내용을 통해 우리가 배운 컴퓨터 프로그래밍에서의 **`'동적계획법'`**이란 `'동적계획법'을 통해 결론을 도출해야하는 문제의 각 단계 별 최적값을 '메모이제이션'하여 향후에 필요할 때 다시 꺼내어 보는 것'` 을 의미한다. 이를 적용하면 위 순서에서 3,4번을 거치며 알게된 num(3)=2, num(2)=1이라는 결과값을 어딘가 메모해두고 num(4)를 구하는 5번 단계를 진행할 때 그 메모를 이용해 바로 문제를 풀 수 있게 된다. 또한, 다시 최초의 재귀식인 num(n) = num(n-1)+num(n-2)로 돌아갔을 때 남아있는 num(n-2)의 값은 다시 구할 필요도 없이 메모해놓은 값을 사용하면되니, 시간이 거의 반으로 줄게되는 것이다.  
  
나는 이것을 하나의 `**'데이터베이스를 만드는 것'**`으로 이해했다. 이는 두가지 조건만 만족하면 어디든 사용할 수 있다. 하나는 `'하나의 결론에 도달하기 위해 여러 단계가 필요하고 각 단계가 최적값을 가져야 한다.'` 이며, 두 번째는 `'해당 단계들이 반복해서 일어난다.'` 이다. 꼭 재귀가 아니어도 온갖 간단한 것들이 여기에 포함된다. 예를 들어 일정 숫자 사이에 있는 소수를 전부 구하는 [백준 4948번 '베르트랑 공준' 문제](https://www.acmicpc.net/problem/4948)도 동적계획법을 사용할 수 있다고 볼 수 있다. 이 문제는 크게 두 단계로 나눠지는데 '1) 0~2n 사이의 소수를 구한다.'와 '2) n~2n 사이의 소수를 찾는다.' 이다. 이 때 이 문제에 동적계획법이 적용된다고 한 이유는 '입력값을 여러개 받기 때문'이다. 입력값을 여러개 받아 매 입력값 n 마다 n~2n 사이의 소수를 출력해야하기 때문에, 자연스레 '1) 0~2n 사이의 소수를 구한다.'라는 단계가 반복되게 된다. 이를 동적계획법을 이용하여 입력받은 숫자 중 가장 큰 값 M에 대해 0~2M 사이에 있는 소수를 모두 구해 메모이제이션 해놓으면, 그보다 작은 숫자들에 대한 답을 구할 때는 그저 2)번 과정만 거치면 되는 것이다.  
  
사실 계속해서 동적계획법을 사용하고 있었던 것이나 다름 없는데, 좀 더 큰 관점에서 문제를 바라볼 수 있게된 것 같다. 그리고 풀이법을 떠올릴 때 좀 더 뚜렷해진 기분도 든다. 이 것으로 2주차 WIL은 끗!  
  
※ 이 외에 DFS와 BFS, 브루트포스, 그리디 알고리즘 등은 개념 정리만 [TIL](https://github.com/beadoer1/TIL)에 하고, 문제 풀이([Algorithm 문제풀이](https://github.com/beadoer1/algorithm)) 해보는 것으로 마무리하려 한다. 2주차도 고생했다~  
  
### 즐거움
- 웹 개발보다 더 작은(?) 것 하나에 완전히 몰두하는 경험
- 알고리즘 문제를 보고 풀이법이 연상되는 마법
- 풀어온 알고리즘 문제들과 수업 실습을 모두 정리했다! 매우 좋다.
  
### 아쉬움
- DFS, BFS 를 정확히 이해하지 못한 것 같다.(블로그 다 쓰고 TIL에 정리 해야지.)
- 몸이 많이 피로하다.  
  피로함을 자주 느낀다. 공부하는 시간 외에 운동도하고 숙면도 취하려고 노력해야겠다는 생각이다.  
  좀 더 밀도있게 공부해야겠다는 생각도 함께_  
  
### 전체적으로..
망망대해에서 나아가는 방법을 알아가고 있는 기분이다. 여기저기 노도 던져주고, 배를 고치라고 망치와 못도 던져 주신다랄까. '끝에는 어디든 섬에 도착하겠지?' 하는 생각과 함께 나침반을 잘 볼 수 있는 방법은 뭘까 의문을 갖게 된다. 곰곰이 생각해보자.
