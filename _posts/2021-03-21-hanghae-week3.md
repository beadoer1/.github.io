---
title: "항해99 3주차 WIL(알고리즘 풀이, Spring의 시작)"
date: 2021-03-22 03:03:00 +0900
categories:
  - 항해99 WIL
tags:
  - 항해99
  - WIL
  - Week I Learned
  - week3
---

※ 알고리즘 풀이 [github.com/beadoer1/algorithm](https://github.com/beadoer1/algorithm)  
※ 관련 지식정리 [github.com/beadoer1/TIL](https://github.com/beadoer1/TIL)  

 
## 알고리즘 집중 기간 종료. 그리고 Spring의 시작.
이번주 목요일까지 하여 알고리즘 집중 기간이 종료되었다. 금요일 시험을 통해 아직 많이 부족함을 느껴서 앞으로도 꾸준히 조금씩 풀어볼 생각이다. 그리고 금요일부터 Spring의 시작. 본격적으로 부트캠프 종료까지 Java Spring을 만지게 될 예정이다. 이제 막 이틀 정도 보았는데, 그 얼개에 대해 이해해 보는 시간이 되었다. 각각 한 가지 이야기를 적어본다.  
  
## 알고리즘 풀이에 대한 고찰
### 다른 사람의 코드를 보는건 선택이 아니라 필수일지도..  
알고리즘 기간동안 어떻게든 나 혼자 풀어내는걸 미학으로 여겼었다. 아예 논리조차 세워지지 않는다면 어쩔 수 없지만 내 생각을 코드로 표현하는 능력을 기르려면 어떻게든 끝까지 구현해보는 것이 더 좋다는 결론이었다. 지금도 그 생각이 전부 틀렸다고 느끼지는 않지만, 결과의 성패에 상관없이 이후에 다른 사람의 코드를 보는 것이 많은 도움이 된다는 것도 느낀 한 주였다. 아예 풀지 못한 문제들을 한 번 정리하며 다른 이들의 코드를 자세히 보게 되었는데 그 과정에서 느낀 점이 많았다. 어떤 도움이 되었는지 정리해본다.  
```
# 풀이 : 다른 사람 풀이(이를 통해 BFS를 이해해보자.) ↓↓↓아래 코드의 과정↓↓↓
# 6 4
# 0 -1 0 0      0 -1 0 0      0 -1 0 0      0 -1 0 4      0 -1 5 4  결과 : 0이 있네.-> True -> -1 출력
# -1 0 0 0  ->  -1 0 0 0  ->  -1 0 0 3  ->  -1 0 4 3  ->  -1 5 4 3
# 0 0 0 0       0 0 0 2       0 0 3 2       0 4 3 2       5 4 3 2
# 0 0 0 1       0 0 2 1       0 3 2 1       4 3 2 1       4 3 2 1

from collections import deque # BFS 에 유리한 queue 사용을 위한 collections import

M, N = map(int, input().split()) # 입력을 받는다. M : 상자의 가로 칸 수, N : 상자의 세로 칸 수
tots = [list(map(int, input().split())) for _ in range(N)] # 각 줄의 상자들을 입력 받는다.
queue = deque() # to_visit 의 개념으로 현재 이미 익어있는 토마토의 좌표를 먼저 저장하고 향후 새로 익은 토마토를 추가로 넣어줄 용도

for i in range(N): # 이미 익어있는 토마토들에 우선 방문하기 위해 좌표 list [i,j]를 append 해준다.
    for j in range(M):
        if tots[i][j] == 1:
            queue.append([i, j])

# 상하좌우 체크를 위한 x,y 좌표에 더해줄 값 list ★★★★★, BFS 하려면 모르면 안될 내용일듯.(코드가 엄청 깔끔해진다.)         
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

# 여기부터 bfs
while queue:
    row, col = queue.popleft() # 익어있는(1) 토마토에 방문하기 위해 popleft(). ★list [row,col]을 좌측과 같이 받을 수 있다.★
    
    for k in range(4):
        _row = row + dy[k]     # 익어있는 토마토 상하좌우(dx,dy)를 확인하기 위한 변수 _row, _col
        _col = col + dx[k]
        
        # 안익은게 있다면, 익은 것으로 바꿔준다.
        if 0 <= _row < N and 0 <= _col < M and tots[_row][_col] == 0: # indexError 방지를 위한 조건 과 안익은 토마토인지 확인하는 조건
            tots[_row][_col] = tots[row][col] + 1 # 안 익은 토마토를 익은 토마토로 바꿔 준다.(단계 표현을 위해 + 1 해준다. 첫 날:2,둘 째 날:3, ..)
            queue.append([_row, _col]) # 이제 익은 토마토를 향후에 방문하기 위해 큐에 넣어 준다.
# bfs 끝

result = -2 # -1이 존재해서 -2 값으로 비교

check_tot = False # 안익은게 있는지 체크하기 위한 bool 변수

for i in tots: # tots list 안에 있는 list들의 변수 i
    for j in i: # tots list 안에 i list 안에 원소들의 변수 j
        if(j == 0): # 남아있는 원소들 중 0이 있으면
            check_tot = True # True로 변경
        result = max(result, j) # j가 1인 경우에는??
        
if check_tot: # 남아있는 원소들 중에 0이 있는 경우 
    print(-1)
elif result == -1: # 처음부터 모두 -1일 때를 대비한 조건
    print(0)
else: 
    print(result - 1) # 모두 익은 상황

※ 코드 출처 : https://hwiyong.tistory.com/389 '대학원생이 쉽게 설명해보기' 블로그
```
위 코드는 [백준 7576번 토마토 문제](https://www.acmicpc.net/problem/7576)에 대한 다른 사람의 풀이이다. 거기에 주석을 통해 한 줄 한 줄 이해하면서 해석을 달아보았다.  
  
개인적으로 2주 간의 알고리즘 집중 기간을 가지며 알고리즘 테스트는 무슨 의미를 가지는가에 대해 자주 생각해보았다. 결론적으로 3가지 정도의 이유가 있다는 결론을 내렸고 이는 다음과 같다.
```
1. 문제 자체를 풀 수 있는 논리력
2. 본인의 논리를 코드로 표현할 수 있는 능력
3. 코드를 효율적으로 작성하는 능력
```
그리고 위 토마토 풀이를 보고 해석하며 위 세가지 능력을 모두 향상시킬 수 있음을 느꼈다. 당연할 수 있지만, 많은 경우에 발생하는 문제가 당연함을 당연하다는 이유로 지나쳐 발생하기도 하므로 글로써 남겨본다.
  
1. 논리력  
먼저, 나는 위 토마토 문제를 끝내 내 힘으로 풀지 못했다. DFS, BFS에 대해 자세히 알지 못해 그럴 수 있다는 생각에 다시 한 번 정리도 해보며 풀어보려 했지만, 도저히 풀이법이 떠오르지 않았다. 그리고 위 풀이를 보았는데, 그야말로 유레카 였다. '상하좌우를 지정하여 0인 수를 바꾼다.'라는 개념은 누구나 떠올릴 수 있겠으나, 몇 일이 지났는지를 나타내기 위해 '매 단계별로 방문 숫자에 +1하여 번호를 메겨주는 부분'이 그랬다. 어쩌면 너무나 간단한 방법이지만 보지 않았다면 생각을 접었거나 언제까지고 떠오르지 않았을 수도 있었다고 본다. 타인의 코드를 통해 문제를 바라보는 시야를 넓힐 수 있었다. 이를 이용해 유사 문제인 [백준 2667번 '단지번호붙이기'](https://www.acmicpc.net/problem/2667)를 해결하기도 하였다. [풀이](https://github.com/beadoer1/algorithm/blob/master/20210318/2667.py)  
  
2. 논리를 코드로 구현하는 능력  
논리를 세우는 것과 코드를 구현하는 것은 또다른 문제이다. 코드를 구현할 때는 단순히 논리만 맞아야 하는 것이 아니고, 프로그래밍 언어 특성 또한 잘 알아야 한다. 일례로 위 코드에서 `if 0 <= _row < N and 0 <= _col < M` 이 부분을 들 수 있다. 이는 지정해놓은 2중 배열의 범위 안에 있는지 체크하는 것으로 해당 부분을 넣지 않은 채 코드를 실행하면 `indexError`를 발생시키게 된다. 꽤나 자주 indexError로 고생한 것을 생각해본다면, 매 번 그때그때 해결했음에 만족하고 지나간 것이 아닌가 하는 생각이 든다. 다른 이의 코드를 보며 너무도 간결하게 해결해놓은 것을 확인하고 자존심에 약간의 스크래치와 함께 더 오래 기억하게 되는 듯 하다.  
이와 함께 많은 경우, 논리에 대한 아이디어를 얻고 난 후 그 허점에 대해 깊게 생각하지 않고 코드를 두들기는 오류를 반복했다. 위 코드에서는 result 판별을 위해 '-2'를 넣는 행위라던지 매일 익어가는 토마토에 다른 숫자를 붙이는 행위가 그 깊은 생각 결과의 차이 라고 볼 수 있을 듯 하다. 완전한 답을 나타낼 수 있는 논리를 먼저 세우는 것이 중요하다.  
  
3. 코드를 효율적으로 작성하는 능력
같은 내용의 코드라도 그 모습은 사람마다 다르게 나오는 경우가 허다하다. 게다가 나는 매번 코드의 길이가 남들에 비해 많이 긴 편이었는데, 이는 지식 부족과 지혜 부족에 따라 발생했다. 먼저, 지식 부족의 경우 `row, col = queue.popleft()` 이 코드를 들 수 있다. row와 col에 queue.popleft()[0]과 queue.popleft()[1]을 뽑아내는 것인데 이 풀이를 보기 전 나라면 두 번에 나누어 각각에 대입해줬을 것이다. 모르는 건 배워야 할 수 있다. 그리고 지혜 부족에 대해 보자면, `dx, dy를 지정하고 반복문을 통해 상하좌우를 표현한 부분`이 그랬다. 이전에도 상하좌우를 방문하는 형태로 풀어보긴 했으나 그 때는 `[x][y+1],[x][y-1],[x+1][y],[x-1][y]`를 이용해 전부 다 조건문을 돌리는 식으로 풀었었다. 지혜 또한 나의 부족함을 맞닥뜨려야 느는게 아닐까 한다.  
  
### 알고리즘 집중 기간을 마치며..
무척 지치는 기간이었다. 문제가 풀리지 않으면 5~6시간씩 한 문제만 보고 있기도 했고, 쏟아지는 알고리즘 개념에 골머리를 앓기도 했다. 그런데 아이러니하게도 이 기간이 끝날 즘 '나중에 어느 때엔가 이 순간이 그리워질 수도 있겠다.' 라고 생각했다. 아무 생각없이 알고리즘에 집중했다. 미래에 있을 테스트 라던지, 취업에 대한 생각보다는 그냥 눈 앞에 있는 이 문제들을 푸는데 집중했다. 그래서 한 편으로 즐거웠다. 현실 속 사회는 오롯이 집중하기 어렵다는 것을 알아서 그랬는지 모르겠다. 세상물정 모르던 어린 시절에 눈높이 교재를 침대 밑에 숨기던 기억이 났다.  

## 웹 개발의 봄, Spring. 본격적 주특기 항해의 시작.
### Java, Spring.. 조급해하지 말자.
금요일, 토요일 미션으로 스파르타코딩클럽 Spring 강의를 전부 듣는 것이 떨어졌고, 다 보고난 지금은 '그래서 도대체 Spring은 뭐하는 놈인데??' 라는 의문이 완전히 해소되지 않는다. `개발자가 'Controller(클라이언트의 요청 접수), Service(실제 기능 구현), Repository(DB 접근)' 3계층의 역할을 하게끔 그 기능을 코딩한 후 Annotation으로 Spring에 해당 역할을 하는 클래스는 이거다 라고 알려주면 Spring이 서버가 돌아가는 동안 발생하는 요청들에 맞추어 자동으로 해당 클래스들을 이용해 객체를 생성/삭제하는 등 프로그램 전반을 컨트롤한다.` 라는게 지금까지 내 머리에 저장된 Spring이다. 뭔가 개운하지 않았다. 본질을 놓치고 있는 느낌이랄까. 그래서 오늘 IoC(Inversion of Control), DI(Dependency Injection) 등 Spring의 중심 개념에 대해 찾아보았는데... 더 수렁에 빠지고 있는 느낌이다. 예전에 프로그래밍 처음 시작할 때 뭐가뭔지도 모르고 코드를 복사해서 붙이던 그 느낌과 유사하다.  
그래서.. 조급해졌다. 이제 Spring을 접한지 이틀 되었는데, 마음이 급해져버린 것이다. 마음을 다잡을 필요가 있다. 일단은 과제는 있는 코드의 형태에 따라 작성하면서 눈으로 익히되, 따로 시간을 내서 김영한 선생님의 '스프링 핵심 원리-기본편'을 들을 생각이다. 조급해하지 말자.  
그래도 긍정적인건, Spring을 통해 웹서버를 돌리고 api 요청을 해보는 등 큰 얼개에 대한 감은 잡아가고 있다는 점이다. 첫 주에 했던 정도의 웹페이지는 어떻게든 만들 수 있겠다는 생각이 든다. 차근차근 해나가보자.


### 즐거움
- 다른 이의 코드를 보며 그들의 시각을 간접적으로나마 경험할 수 있었다.
- Spring을 통해 실제 서버를 띄우고 api 요청을 해보았다. 정확한 원리는 아직 이해하지 못했으나, 파이썬을 가지고 하던 내용과 비교해 일단은 웹페이지를 만들라고 하면 가능은 하겠다라는 자신감을 갖게 되었다. 
  
### 개선점
- Spring 이틀 차에 많이 알아야한다는 조급함이 들어 맥락없이 검색만 두들겼다. 차근차근 해나가자.
- 자바의 정석을 한 달 반 동안 봤음에도 부트캠프 3주 사이에 많은 부분이 희미해졌다. 인터페이스, 애너테이션 등 Spring 사용에 중요한 부분들을 틈틈이 다시보자.(특히나 애너테이션은 주석 쯤으로 생각했던 과거를 반성하자.)
  
### 전체적으로..
시험을 통해 2주로는 많이 부족하다는 것을 깨달음과 함께 알고리즘 주차가 끝나고 주특기 기간이 시작되었다. 지금부터는 부트캠프 종료까지 Java, Spring만 주구장창 하게 될 예정이다. 자바를 조금이라도 공부했다는 생각에 나는 더 빨라야할 것 같았고, 핵심은 알지 못하고 Spring을 공부하고 있다는 생각에 조바심이 났다. 하루 즘 바다에 빠져 허우적거린 느낌이다. 바닷물을 먹어 정신이 좀 없지만, 어떻게 다시 배 위로는 올라왔다고 생각한다. 찬찬히 주변도 살피고 다시 노를 저어보자!